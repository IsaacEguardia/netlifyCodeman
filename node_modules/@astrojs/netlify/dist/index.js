import { fileURLToPath } from 'url';
import { createRedirectsFromAstroRoutes } from '@astrojs/underscore-redirects';
import { AstroError } from 'astro/errors';
import { build } from 'esbuild';
import { appendFile, mkdir, readFile, rm, writeFile } from 'fs/promises';
const { version: packageVersion } = JSON.parse(await readFile(new URL('../package.json', import.meta.url), 'utf8'));
const isStaticRedirect = (route) => route.type === 'redirect' && (route.redirect || route.redirectRoute);
const clearDirectory = (dir) => rm(dir, { recursive: true }).catch(() => { });
export default function netlifyIntegration(integrationConfig) {
    const isRunningInNetlify = Boolean(process.env.NETLIFY || process.env.NETLIFY_LOCAL || process.env.NETLIFY_DEV);
    let _config;
    let outDir;
    let rootDir;
    let astroMiddlewareEntryPoint = undefined;
    const ssrOutputDir = () => new URL('./.netlify/functions-internal/ssr/', rootDir);
    const middlewareOutputDir = () => new URL('.netlify/edge-functions/middleware/', rootDir);
    const cleanFunctions = async () => await Promise.all([clearDirectory(middlewareOutputDir()), clearDirectory(ssrOutputDir())]);
    async function writeRedirects(routes, dir) {
        const fallback = _config.output === 'static' ? '/.netlify/static' : '/.netlify/functions/ssr';
        const redirects = createRedirectsFromAstroRoutes({
            config: _config,
            dir,
            routeToDynamicTargetMap: new Map(routes
                .filter(isStaticRedirect) // all other routes are handled by SSR
                .map((route) => {
                // this is needed to support redirects to dynamic routes
                // on static. not sure why this is needed, but it works.
                route.distURL ??= route.redirectRoute?.distURL;
                return [route, fallback];
            })),
        });
        if (!redirects.empty()) {
            await appendFile(new URL('_redirects', outDir), `\n${redirects.print()}\n`);
        }
    }
    async function writeSSRFunction() {
        await writeFile(new URL('./ssr.mjs', ssrOutputDir()), `
				import createSSRHandler from './entry.mjs';
				export default createSSRHandler(${JSON.stringify({
            cacheOnDemandPages: Boolean(integrationConfig?.cacheOnDemandPages),
        })});
				export const config = { name: "Astro SSR", generator: "@astrojs/netlify@${packageVersion}", path: "/*", preferStatic: true };
			`);
    }
    async function writeMiddleware(entrypoint) {
        await mkdir(middlewareOutputDir(), { recursive: true });
        await writeFile(new URL('./entry.mjs', middlewareOutputDir()), `
			import { onRequest } from "${fileURLToPath(entrypoint).replaceAll('\\', '/')}";
			import { createContext, trySerializeLocals } from 'astro/middleware';

			export default async (request, context) => {
				const ctx = createContext({ 
					request,
					params: {}
				});
				ctx.locals = { netlify: { context } }
				const next = () => {
					const { netlify, ...otherLocals } = ctx.locals;
					request.headers.set("x-astro-locals", trySerializeLocals(otherLocals));
					return context.next();
				};
			
				return onRequest(ctx, next);
			}

			export const config = {
				name: "Astro Middleware",
				generator: "@astrojs/netlify@${packageVersion}",
				path: "/*", excludedPath: ["/_astro/*", "/.netlify/images/*"]
			};
			`);
        // taking over bundling, because Netlify bundling trips over NPM modules
        await build({
            entryPoints: [fileURLToPath(new URL('./entry.mjs', middlewareOutputDir()))],
            target: 'es2022',
            platform: 'neutral',
            outfile: fileURLToPath(new URL('./middleware.mjs', middlewareOutputDir())),
            allowOverwrite: true,
            format: 'esm',
            bundle: true,
            minify: false,
        });
    }
    function getLocalDevNetlifyContext(req) {
        const isHttps = req.headers['x-forwarded-proto'] === 'https';
        const parseBase64JSON = (header) => {
            if (typeof req.headers[header] === 'string') {
                try {
                    return JSON.parse(Buffer.from(req.headers[header], 'base64').toString('utf8'));
                }
                catch { }
            }
        };
        const context = {
            account: parseBase64JSON('x-nf-account-info') ?? {
                id: 'mock-netlify-account-id',
            },
            deploy: {
                id: typeof req.headers['x-nf-deploy-id'] === 'string'
                    ? req.headers['x-nf-deploy-id']
                    : 'mock-netlify-deploy-id',
            },
            site: parseBase64JSON('x-nf-site-info') ?? {
                id: 'mock-netlify-site-id',
                name: 'mock-netlify-site.netlify.app',
                url: `${isHttps ? 'https' : 'http'}://localhost:${isRunningInNetlify ? 8888 : 4321}`,
            },
            geo: parseBase64JSON('x-nf-geo') ?? {
                city: 'Mock City',
                country: { code: 'mock', name: 'Mock Country' },
                subdivision: { code: 'SD', name: 'Mock Subdivision' },
                // @ts-expect-error: these are smhw missing from the Netlify types - fix is on the way
                timezone: 'UTC',
                longitude: 0,
                latitude: 0,
            },
            ip: typeof req.headers['x-nf-client-connection-ip'] === 'string'
                ? req.headers['x-nf-client-connection-ip']
                : req.socket.remoteAddress ?? '127.0.0.1',
            server: {
                region: 'local-dev',
            },
            requestId: typeof req.headers['x-nf-request-id'] === 'string'
                ? req.headers['x-nf-request-id']
                : 'mock-netlify-request-id',
            get cookies() {
                throw new Error('Please use Astro.cookies instead.');
            },
            json: (input) => Response.json(input),
            log: console.log,
            next: () => {
                throw new Error('`context.next` is not implemented for serverless functions');
            },
            get params() {
                throw new Error("context.params don't contain any usable content in Astro.");
            },
            rewrite() {
                throw new Error('context.rewrite is not available in Astro.');
            },
        };
        return context;
    }
    return {
        name: '@astrojs/netlify',
        hooks: {
            'astro:config:setup': async ({ config, updateConfig }) => {
                rootDir = config.root;
                await cleanFunctions();
                outDir = new URL('./dist/', rootDir);
                const enableImageCDN = isRunningInNetlify && (integrationConfig?.imageCDN ?? true);
                updateConfig({
                    outDir,
                    build: {
                        redirects: false,
                        client: outDir,
                        server: ssrOutputDir(),
                    },
                    vite: {
                        server: {
                            watch: {
                                ignored: [fileURLToPath(new URL('./.netlify/**', rootDir))],
                            },
                        },
                    },
                    image: {
                        service: {
                            entrypoint: enableImageCDN ? '@astrojs/netlify/image-service.js' : undefined,
                        },
                    },
                });
            },
            'astro:config:done': ({ config, setAdapter }) => {
                rootDir = config.root;
                _config = config;
                if (config.image.domains.length || config.image.remotePatterns.length) {
                    throw new AstroError("config.image.domains and config.image.remotePatterns aren't supported by the Netlify adapter.", 'See https://github.com/withastro/adapters/tree/main/packages/netlify#image-cdn for more.');
                }
                setAdapter({
                    name: '@astrojs/netlify',
                    serverEntrypoint: '@astrojs/netlify/ssr-function.js',
                    exports: ['default'],
                    adapterFeatures: {
                        functionPerRoute: false,
                        edgeMiddleware: integrationConfig?.edgeMiddleware ?? false,
                    },
                    supportedAstroFeatures: {
                        hybridOutput: 'stable',
                        staticOutput: 'stable',
                        serverOutput: 'stable',
                        assets: {
                            // keeping this as experimental at least until Netlify Image CDN is out of beta
                            supportKind: 'experimental',
                            // still using Netlify Image CDN instead
                            isSharpCompatible: true,
                            isSquooshCompatible: true,
                        },
                    },
                });
            },
            'astro:build:ssr': async ({ middlewareEntryPoint }) => {
                astroMiddlewareEntryPoint = middlewareEntryPoint;
            },
            'astro:build:done': async ({ routes, dir, logger }) => {
                await writeRedirects(routes, dir);
                logger.info('Emitted _redirects');
                if (_config.output !== 'static') {
                    await writeSSRFunction();
                    logger.info('Generated SSR Function');
                }
                if (astroMiddlewareEntryPoint) {
                    await writeMiddleware(astroMiddlewareEntryPoint);
                    logger.info('Generated Middleware Edge Function');
                }
            },
            // local dev
            'astro:server:setup': async ({ server }) => {
                server.middlewares.use((req, res, next) => {
                    const locals = Symbol.for('astro.locals');
                    Reflect.set(req, locals, {
                        ...Reflect.get(req, locals),
                        netlify: { context: getLocalDevNetlifyContext(req) },
                    });
                    next();
                });
            },
        },
    };
}
